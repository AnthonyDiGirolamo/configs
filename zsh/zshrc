#!/usr/bin/zsh
stty stop undef
stty start undef
source ~/.aliases

#ZSHLOC=`dirname \`which zsh\``
#ZSHVER=`zsh --version | awk '{print $2}'`
#export FPATH=$ZSHLOC/../share/zsh/$ZSHVER/functions:/usr/share/zsh/$ZSHVER/functions
fpath=(~/.zsh/func $fpath)
typeset -U fpath
export FPATH=`echo $fpath | sed 's/ /:/g'`

autoload -U zmv

r() {
  local f; f=(~/.zsh/func/*(.))
  unfunction $f:t 2> /dev/null
  autoload -U $f:t
}

# Emacs Mode
bindkey -e
# VI Mode
# bindkey -v

setopt auto_pushd
setopt menucomplete
setopt inc_append_history append_history share_history
setopt hist_ignore_dups hist_ignore_all_dups
HISTSIZE=10000
SAVEHIST=10000
HISTFILE=~/.zhistory

# # SSH AGENT
# export SSH_ENV=~/.ssh/start_agent
# function start_agent {
#   echo "Initializing new SSH agent..."
#   /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
#   echo succeeded
#   chmod 600 "${SSH_ENV}"
#   . "${SSH_ENV}" > /dev/null
#   /usr/bin/ssh-add;
# }
# # Source SSH settings, if applicable
# if [ -f "${SSH_ENV}" ]; then
#   . "${SSH_ENV}" > /dev/null
#   #ps ${SSH_AGENT_PID} doesn't work under cywgin
#   ps -eA | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
#     start_agent;
#   }
# else
#   start_agent;
# fi

# Sets the screen window title with the name of the command you are running
#preexec () { echo -ne "\ek${1%% *}\e\\" }

# Set color variables with helpful names

# Prompt
# ======
setopt promptsubst
autoload -U promptinit && promptinit
# Run prompt -h for help # prompt wunjo for git aware

autoload -U colors zsh/terminfo && colors
# Super Minimalistic
PS1="%{$fg[green]%}%(!.#.$)%{$reset_color%} "

# Right Justified Prompt
# ======================
# Date Time
#RPS1="(%D{%m-%d %H:%M})"
# Current Directory
local TERMWIDTH
(( TERMWIDTH = ${COLUMNS} - 1 ))
local PROMPTSIZE=${#${(%):--- %D{%R.%S %a %b %d %Y}\! }}
local PWDSIZE=${#${(%):-%~}}
if [[ "$PROMPTSIZE + $PWDSIZE" -gt $TERMWIDTH ]]; then
 (( PR_PWDLEN = $TERMWIDTH - $PROMPTSIZE ))
fi
RPS1="%{$fg[cyan]%}%${PR_PWDLEN}<...<%~%<<%{$reset_color%}"

source ~/.aliases

# Auth your sshkey with another server
function authme {
    ssh $@ 'cat >>.ssh/authorized_keys' <~/.ssh/id_rsa.pub
}

function setupenv {
  pushd ~
	rsync -avLK --delete --exclude mthesaur-vim.txt .gitconfig .vim .vimrc .zsh .zshrc .screenrc .tmux.conf .aliases .irbrc $@:~/
  popd
}

bindkey '^[[1;5D' backward-word
bindkey '^[[1;5C' forward-word

# Typical delete keys
#bindkey '^H' backward-delete-char
#bindkey '^?' backward-delete-char

bindkey '^r' history-incremental-search-backward

bindkey '^I' complete-word # complete on tab, leave expansion to _expand
# bindkey ' ' magic-space    # also do history expansion on space

bindkey '^K' push-line # push current command into a buffer, allows you to do another command then returns to previous command

autoload zkbd
typeset -A key
    key[Home]=${terminfo[khome]}
     key[End]=${terminfo[kend]}
  key[Insert]=${terminfo[kich1]}
  key[Delete]=${terminfo[kdch1]}
      key[Up]=${terminfo[kcuu1]}
    key[Down]=${terminfo[kcud1]}
    key[Left]=${terminfo[kcub1]}
   key[Right]=${terminfo[kcuf1]}
  key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}

for k in ${(k)key} ; do
    # $terminfo[] entries are weird in ncurses application mode...
    [[ ${key[$k]} == $'\eO'* ]] && key[$k]=${key[$k]/O/[}
done
unset k

# [[ -n ${key[Backspace]} ]] && bindkey "${key[Backspace]}" backward-delete-char
# [[ -n ${key[Insert]}    ]] && bindkey "${key[Insert]}"    overwrite-mode
  [[ -n ${key[Home]}      ]] && bindkey "${key[Home]}"      beginning-of-line
  [[ -n ${key[End]}       ]] && bindkey "${key[End]}"       end-of-line
# [[ -n ${key[PageUp]}    ]] && bindkey "${key[PageUp]}"    up-line-or-history
# [[ -n ${key[PageDown]}  ]] && bindkey "${key[PageDown]}"  down-line-or-history
  [[ -n ${key[Delete]}    ]] && bindkey "${key[Delete]}"    delete-char
# [[ -n ${key[Up]}        ]] && bindkey "${key[Up]}"        up-line-or-search
# [[ -n ${key[Left]}      ]] && bindkey "${key[Left]}"      backward-char
# [[ -n ${key[Down]}      ]] && bindkey "${key[Down]}"      down-line-or-search
# [[ -n ${key[Right]}     ]] && bindkey "${key[Right]}"     forward-char

# Completion

# The following lines were added by compinstall
zstyle ':completion:*' completer _expand _complete _ignored _approximate
zstyle ':completion:*' insert-unambiguous false
zstyle ':completion:*' matcher-list '' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'l:|=* r:|=*'
zstyle ':completion:*' menu select=1
zstyle ':completion:*' original true
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle :compinstall filename '/Users/adigiro/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall

zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%B%d%b'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format 'No matches for: %d'
zstyle ':completion:*' group-name ''

zstyle ':completion::complete:*' use-cache on
zstyle ':completion::complete:*' cache-path ~/.zsh/cache/$HOST

zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# allow one error for every three characters typed in approximate completer
zstyle -e ':completion:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/2 )) numeric )'

# kill completion
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*:*:kill:*:processes' command 'ps -A' # 'ps --forest -A -o pid,user,cmd'

# Custom Completion Functions

_use_completion() {
  if [[ -e /packages/usepackage-1.8/bin/usepackage ]]; then
    reply=(`/packages/usepackage-1.8/bin/usepackage -l 2>&1 | sed -e '/^\S/      d' -e '/^$/d' -e 's/^   //g' -e 's/\s-\s.*//g'`)
  fi
}
compctl -K _use_completion use

# Completion Notes
# ----------------
# Case Insensitive with -M
#   compctl -M 'm:{a-zA-Z}={A-Za-z}' -K function command
# Replace tab completion text with results with -U
#   compctl -U -K function command
# Function Name begins with '_' use 'read -l'
#   read -l query
#   query=${query/gn /} # Delete 'gn ' from the query variable
# Function Name does NOT begin with '_'
#   echo $@
#
# if [[ -e $HOME/Notes/$@ ]]; then # Check file existence first
# fi

# Replacing / with \/ in the HOME variable so that sed can search for '/'
# sed -e "s/${HOME//\//\\/}\/Notes\///"

# Getting the length of a variable and subtracting 1
# query=$@
# print $((${#query} - 1))

note_directory=$HOME/Notes
note_directory_escaped=${note_directory//\//\\/}\\\/

note_filename_completion() {
  reply=(`find -L $note_directory | sed -e "s/$note_directory_escaped//"`)
}
note_grep_completion() {
  reply=(`grep -Iirls --exclude="*\.log" --exclude="*bz2" --exclude="*gz" "$@" $note_directory | sed -e "s/$note_directory_escaped//"`)
}

# Edit or Create Note
n() { vim $note_directory/$@ }
# Copy Notes
cn() { cat "$note_directory/$@" | pbcopy }

compctl -M 'm:{a-zA-Z}={A-Za-z}' -K note_filename_completion -J names -X '%BFile Names' -t+ + -U -K note_grep_completion -J grep -X '%BGrep Notes' n
compctl -M 'm:{a-zA-Z}={A-Za-z}' -K note_filename_completion -J names -X '%BFile Names' -t+ + -U -K note_grep_completion -J grep -X '%BGrep Notes' cn

# RVM Source
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"

